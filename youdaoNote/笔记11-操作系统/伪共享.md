

一.CPU
1.缓冲行
一般一行缓存行有64字节(由上图”64-byte line size”可知)。所以使用缓存时，并不是一个一个字节使用，而是一行缓存行、一行缓存行这样使用；换句话说，CPU存取缓存都是按照一行，为最小单位操作的。
如果没有好好利用缓存行的话，程序可能会遇到性能的问题。

确保两个引用，不在同一cache line上，防止多锁竞争。
就是一个引用占满64字节。

2.伪共享
伪共享, 是指多个线程修改同一缓存行中的不同变量时，会发生互相影响，降低性能。在一个SMP系统中，对同一缓存行的写入竞争，是影响并发线程运行的主要限制因素。有人将伪共享描述成无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。
为了达到线性的可扩展性，就必须确保不会有两个线程往同一个变量或缓存行中写。两个线程写同一个变量可以在代码中发现。为了确定互相独立的变量是否共享了同一个缓存行，就需要了解内存布局，或找个工具告诉我们。
Intel VTune就是这样一个分析工具。本文中我将解释Java对象的内存布局以及我们该如何填充缓存行以避免伪共享。
http://www.nathanyan.com/2015/08/14/%E4%BC%AA%E5%85%B1%E4%BA%AB-False-Sharing/