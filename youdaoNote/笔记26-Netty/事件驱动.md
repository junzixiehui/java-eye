事件驱动

> 事件驱动的程序一般都有一个主循环（main loop）或称事件循环，该循环不停地做两件 事：事件监测和事件处理。首先要监测是否发生了事件，如果有事件发生则调用相应的事件 处理程序，处理完毕再继续监测新事件。

> 常见传统模型中是利用多线程模型；通信层负责tcp连接，业务逻辑层处理业务；当并发大的时候，会创建很多线程连接并处理业务，于是在通信层引入事件驱动；通信层只管获取连接tcp，获取之后交给线程池处理业务；
于是：常见的模型，纷纷把通信层剥离出来，用事件驱动的形式取代多线程，但是在业务逻辑层仍然采用多线程模型。几个著名的例子:
- nginx负责通信层，PHP-FPM负责业务逻辑层
- nginx负责通信层，uwsgi负责Python的业务逻辑层
- tomcat nio负责通信层，业务逻辑层扔到线程池里处理

> 当在业务逻辑层处理IO等耗时操作的时候，于是引入在业务逻辑层事件驱动；
 所以第二代事件驱动模型应运而生，把业务逻辑也变成事件驱动，彻底消除浪费线程等待IO这个现象。事件驱动有两件常见的外衣，一件是异步回调，另一件是coroutine，近几年有了很多应用：
-  Go的goroutine
- Python 3的coroutine
- Kotlin的coroutine
- nodejs的异步回调
- swoole 1的异步回调和swoole2的coroutineerlang/elixir的process也算是coroutine
- VertX的异步回调

> 采用事件循环，则是把每个请求放到一个watchList中，每次去检查这个列表，看是否有新的事件到达，如果有则处理。这样便不会浪费cpu的时间。




