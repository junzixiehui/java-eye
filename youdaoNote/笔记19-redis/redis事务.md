

> redis事务和我们平常提到的事务概念是有明显区别的。redis事务设计的理念是简单和性能。
- 所以我们平常的关系数据库事务在执行前会发送一个being,然后执行数据读或写，最后可以选择commit或者回滚命令。
- redis事务以MULTI命令开始，服务端不会执行，直到接到EXEC命令之后才会批量执行。所以客户端不能根据事务中的读数据命令去做一些判断等。
严格意义上 redis事务并不是严格意义上的事务。


#### 解决redis事务的不足

- 在执行事务命令的时候，你可以利用WATCH监控你关心的字段变更，当在执行事务里面批量命令的时候，你关心的字段如果被其他客户端变了，就会报错。你可以选择重试或者其它办法处理错误。可以去掉监控用UNWATCH.
- 例如有个案例 你要将你游戏里拥有的道具放到道具市场上出售。在放的过程中 你要监控该道具是否还存在你的道具库里。
- 

#### 原理实现

- redisclient客户端对象，每一个连接redis服务器的系统都会对应一个redisclient对象。
- MULTI命令会开启事务状态，就是修改redisclient中一个值。
- EXEC会清除事务状态 事务队列命令 返回回复队列
- WATCH命令会在redisDb对象中有一个字典的监控键对象，key是被监控的键，值是监控这个键的客户端。每当执行set hset等修改命令的时候，都会遍历这个key对应的客户端对象，将某个值状态改变。事务exec将返回nio错误。
- 

#### ACID
- 原子性 事务要么全部执行，要么一个也不执行。redis符合原子性。但是redis没有提供回滚命令，即时其中一个事务命令出错，redis依旧会执行完毕。不提供回滚的原因是与redis的高效设计不符合。这种现象在开发阶段是可以提前测出并可以屏蔽的。
- 一致性 事务执行前后，无论是否执行成功，数据库都是一致的。一致 是指数据库没有非法或者错误数据。redis通过检测和简单设计保证一致性。
> redis 事务命令入队之前对命令进行检测，如果无效命令拒绝执行。
- 隔离性 多个事务执行 在并发和串行中互相不影响。redis服务器保证事务命令不会中断，且总是以串行方式运行。
- 持久性 数据库事务执行完毕之后会持久化到磁盘上，及时停机数据不会消失。redis事务持久性是由redis持久性保证的，但是如果redis无持久性设置，redis事务是不能保证持久性的。