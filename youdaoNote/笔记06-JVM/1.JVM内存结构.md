一.JVM内存模型

![image](https://note.youdao.com/yws/api/personal/file/210A79A33B604A21BF19E85B93B047EC?method=download&shareKey=e71113c64538fe999708cb80793998ca)

#### 1.栈
的基本单位是帧（或栈帧）：每当一个Java线程运行的时候，Java虚拟机会为该线程分配一个Java栈。该线程在执行某个Java方法的时候，向Java栈压入一个帧，这个帧用于存储参数、局部变量、操作数、中间运算结果等。当这个方法执行完的时候，帧会从栈中弹出。Java栈上的所有数据是私有的，其他线程都不能访问该线程的栈数据。在函数中定义的一些基本类型的变量数据和对象的。JAVA为为栈分配内存，当变量退出作用域，释放内存。
线程的每个方法被执行 的时候，都会同时创建一个帧（Frame）用于存储本地变量表、操作栈、动态链接、方法出入口等信息。每一个方法的调用至完成，就意味着一个帧在VM栈中 的入栈至出栈的过程。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果VM栈可以动态扩展（VM Spec中允许固定长度的VM栈），当扩展时无法申请到足够内存则抛出OutOfMemoryError异常
#### 2.堆
![image](https://note.youdao.com/yws/api/personal/file/A666672464124DEFA778D83DA235C7BF?method=download&shareKey=e71113c64538fe999708cb80793998ca)

Java虚拟机中的堆用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收机制来管理堆的内存。简单的说和栈相对，**堆主要是用来存放Java对象的，栈主要是用来存放对象引用的**。在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或对象起的一个名称。
 
引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用new产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能再被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是Java比较占内存的原因。实际上，栈中的变量指向堆内存中的变量，这就是Java中的指针！
 
 
java的堆是一个运行时数据区，类的对象从中分配空间。这些对象通过new + 构造器等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。
 
3.栈的优势
是存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量数据（int，short，long，byte，float，double，boolean，char）和对象引用。
栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：int a=3；int b=3；编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3，接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。
 
注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b，它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。
#### 4.方法区
  ● 也称为永久代（Permanent Generation）但随着Java8的到来，已放弃永久代改为采用Native Memory来实现方法区的规划。
  ● 此区域回收目标主要是针对常量池的回收和对类型的卸载。
  ● 方法区中存放了每个Class的结构信息，包括常量池、字段描述、方法描述等等。VM Space描述中对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存，也可以选择固定大小或者可扩展外，甚至可以选择不实现垃圾收集。相对 来说，垃圾收集行为在这个区域是相对比较少发生的，但并不是某些描述那样永久代不会发生GC（至 少对当前主流的商业JVM实现来说是如此），这里的GC主要是对常量池的回收和对类的卸载，虽然回收的“成绩”一般也比较差强人意，尤其是类卸载，条件相 当苛刻。
#### 5.常量池
 Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量表(constant_pool table)，用于存放编译期已可知的常量，这部分内容将在类加载后进入方法区（永久代）存放。但是Java语言并不要求常量一定只有编译期预置入 Class的常量表的内容才能进入方法区常量池，运行期间也可将新内容放入常量池（最典型的String.intern()方法）。
#### 6.程序计数器
每一个Java线程都有一个程序计数器来用于保存程序执行到当前方法的哪一个指令。
程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。
　　每个程序计数器只用来记录一个线程的行号，所以它是线程私有（一个线程就有一个程序计数器）的。
　 　如果程序执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（native，由C语言编写 完成）方法，则计数器的值为Undefined，由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，程序计数器也是所有JVM内存区 域中唯一一个没有定义OutOfMemoryError的区域。
#### 7.直接内存
直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。
  ● 能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。
  ● 直接内存的分配不会受到Java堆大小的限制，但会收到本机总内存（RAM以及SWAP/分页文件）大小以及处理器寻址空间的限制。
  ● 设置Xmx等参数信息时注意不能忽略直接内存，不然会引起OOM。
