



- 并发的反义词是顺序，concurrency vs sequential，



> 例如：顺序处理：你陪女朋友先看电影（Task1），看完后陪女朋友到花店买了一束花（Task2），然后陪女朋友去西餐厅吃烛光晚餐（Task3），这就是“顺序处理”，因为整个过程中只有你这一个处理器，事情只能一件一件的做（要么是你亲自做，要么你要等别人做）。Task1你要花2小时，Task2等花做好你要花30分钟，Task3等菜做好要30分钟，从你开始看电影到开始吃饭，全程需要3小时（假设走路不算时间）。


> 并发处理：你陪女朋友先看电影（Task1），同时打电话给花店预定一束花，花店安排人员在20：00送到西餐厅（Task2）；同时你打电话给西餐定预定20：00的浪漫烛光晚餐，西餐厅开始给你准备晚餐（Task3）；等到你电影看完跑到西餐厅，花也送到了，晚餐也准备好了，你跑过去直接献花吃饭然后开房即可，这就是并发处理。Task1还是2小时，但Task2和Task3也在这2小时完成了，从你开始看电影到开始吃饭，全程只需要2小时，3个任务是并发完成的。秘诀就是有3个处理器了：你、花店、餐厅在同一个时间段内都在做各自的任务。


- 并行的反义词是串行，Parallelism vs Serial，
- 比如说给你一个100万的整形数组，挑出其中最小的值。
- 串行处理

 > 从数组的第一个开始扫描到最后一个，类似冒泡排序一样
 
- 并行处理
 

> 将数组分为10组，每组10万个整形，同时扫描10组得到10个数值，然后再将这10个数值排列一下。上面这个简单的例子也可以看出，串行改为并行其实并不那么简单，涉及到任务分解（有先后依赖的任务就不能做到并行）、任务运行（可能要考虑互斥、锁、共享等）、结果合并。
 

 > 以Java的并行垃圾回收器Parallel为例，标记阶段、回收阶段各自可以多线程并行，但不能将回收阶段和标记阶段一起并行，因为回收阶段的处理依赖标记阶段的结果。